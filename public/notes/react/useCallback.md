# `useCallback`
- 是`useMemo`的函数版本，基本上等同于`useMemo`返回一个函数
- 主要用于对函数的缓存，避免多次声明函数触发不必要的渲染
  - 避免作为子组件的`props`时触发不必要渲染
  - 避免在`useEffect`中调用时触发多次`useEffect`, 当然最好还是直接将函数移入`useEffect`内部 
- 组件顶层调用
- 建议将自定义`hooks`中返回的任何函数都包裹在 `useCallback` 中

## 与`useMemo` 的区别
  - `useMemo` 缓存函数调用的结果
  - `useCallback` 缓存函数本身


## 其他

* 使用`useCallback`需要将函数内部的依赖在第二个参数的依赖数组中声明，依赖一旦改变就会重新声明新的函数，函数内部使用依赖的数据时应该指向对应变量吧 又不是依赖具体的值的快照 应该在每次调用的时候都会准确的拿到该依赖正确的值 为什么还需要在依赖改变的时候重新声明函数呢?
这里需要知道的是`useCallback`的第一个参数是一个数据依赖数组，当依赖的数据改变时就会重新声明，如果依赖数组是空的话就变成每次渲染都会重新声明了

* 函数实际没有依赖项的时候怎么处理
可以使用`useRef`创建函数

* 能不能将所有函数都使用`useCallback`缓存
即使这样做了，也没有很大的坏处。不好的地方可能是降低了代码可读性
