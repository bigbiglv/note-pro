# 迭代器 `Iterator`
- `Iterator` 是一种接口，主要是供应`for...of`消费
- 实现了迭代器的对象称为可迭代对象，也就是实现了 `Symbol.iterator`的对象
  - `Array`
  - `String`
  - `Map`
  - `Set`
  - `类数组对象`
- 可迭代对象每次遍历都会新生成一个迭代器

## 调用 `Iterator` 接口的场合
1. 解构赋值
2. 扩展运算符
3. `yield*`
4. 接收数组作为参数的场合
  - `Map` `Set` `WeakMap` `WeakSet`
  - `Promise.race` `Promise.All`
  - `Array.form`

## 内置了迭代器的对象
- 注意这里的 `arr[Symbol.iterator]` 和后面的 `Generator`不同，这里是一个工厂函数返回一个新的迭代器
- 这个工厂函数不同的可迭代对象针对不同情况实现也不同，但都会返回一个具有`next`方法的对象
```ts
let arr = ['a', 'b', 'c'];
let iterator = arr[Symbol.iterator]();  // 获取数组的迭代器

console.log(iterator.next());  // { value: 'a', done: false }
console.log(iterator.next());  // { value: 'b', done: false }
console.log(iterator.next());  // { value: 'c', done: false }
console.log(iterator.next());  // { value: undefined, done: true }
```

# 生成器 `Generator`
- 生成器函数能创建一个自定义的迭代器
- 生成器可以用于构建状态机
- 语法是`function`后带一个`*`，内部有`yield`， `return`则为结束
- 分段执行，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行

## 调用方式
1. 多次调用 `next()`每次都会得到对应的值以及是否能继续遍历
2. 使用`for...of`直接遍历生成器函数返回的迭代器，遍历时不需要手动调用`next`且会返回对应值
```ts
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  // 这里不会立即求值 而是执行到了next的时候才求值 Lazy Evaluation
  yield 1 + 1;
  return 'ending';
}
var hw = helloWorldGenerator();

console.log(hw.next()) // Object { value: "hello", done: false }
console.log(hw.next()) // Object { value: "world", done: false }
console.log(hw.next()) // Object { value: "ending", done: true }

for(let v of hw) {
  console.log(v) // 'hello'  'world' 
}
```

## 自定义可迭代对象
可迭代对象需要实现 `[Symbol.iterator]` 迭代器生成函数，那就可以手动使用生成器来实现
```ts
// 普通对象没有迭代器不可使用forof遍历
var myIterable = {};
// 自定义一个迭代生成器
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};
// 正常遍历
for(let v of myIterable) {
  console.log(v)
}

// 正常使用迭代器具有的特性
const arr = [...myIterable]

```

## 一些问题
`next`执行后会被消耗，重置只能重新调用生成器函数
```ts
function* helloWorldGenerator() {
  
  yield 'hellow';
  yield 'world';
  return 'ending';
}
var hw = helloWorldGenerator()
// 这里调用了一次next 消耗了第一个值 'hellow'
hw.next()

/**
 * 后续循环会从第二个 yield 开始也就是得到'world'
 * 解决这种情况只能重新生成一个迭代器hw 可迭代对象遍历每次都会新生成一个迭代器
 */
for(let v of hw) {
  console.log(v)
}
```

生成器生成的迭代器对象的[Symbol.iterator]函数执行后会返回自己
```ts
function* gen(){
  // some code
}
var g = gen();
g[Symbol.iterator]() === g // true

```

### 关于 `yield`

```ts
function foo(arg1, arg2) {
  console.log('arg1:', arg1);
  console.log('arg2:', arg2);
}

function* demo() {
  foo(yield 'a', yield 'b'); // OK
  yield '结束'
}

// 使用生成器
const generator = demo();

console.log(generator.next().value); // a
console.log(generator.next('fooValue1').value); // b
/**
 * 第三次执行next后才会触发foo函数 
 * 为什么是第三次不是第二次是因为这里触发执行foo函数需要第二个yield被消耗也就是第三次执行next的时候
 */
/**
 * 这里触发foo函数接收的参数是第2 3次next传递的值 （不理解）
 * 会打印 arg1: fooValue1 arg2: fooValue2
 */
console.log(generator.next('fooValue2').value); // 结束

```
