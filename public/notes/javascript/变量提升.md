# `let` `const`
我的理解是这两种声明方式也会产生变量提升，而是他们会产生变量提升但是会在声明前出现暂时性死区，声明前访问会抛出错误

# `function`
`es6`中函数声明依旧是一等公民，会在代码执行的时候提升到顶部，所以可以在声明前访问。但是这里仅限`function fn() {}` 函数声明的方式，`const fn = () => {}`函数表达式是不行的。
另外函数声明提升只会在本作用域内产生，但也会影响外部作用域，会在全局作用域产生`var fn` 但此时函数还未初始化所以是`undefined`
```ts
console.log(fn) // undefined
// 这里的if条件不影响 即使为false也是同样的效果 只会影响if后续访问fn的值的变化
if(true) {
  console.log(fn) // 正常走函数提升 正常访问
  function fn() {}
}

// 多层作用域的情况依旧一样
console.log(f)
if (true) {
  console.log(f)
  if (true) {
    function f () { console.log('I am inside!')}
  }
}
```
这样的行为在不同的环境会有所差异所以最好不要在**块级作用域**中使用函数声明的形式创建函数，如果实在需要的话应该使用函数表达式`const fn = () => {}`。另外在严格模式下，函数只能声明在当前作用域的顶层

# 块级作用域
关于块级作用域一般是值在 `{}` 中，如`if` `while`等，甚至单独一个`{}`也可，要注意的是没有 `{}` 就不算块级作用域， 如`if`语句只有一行的时候省略了`{}` 